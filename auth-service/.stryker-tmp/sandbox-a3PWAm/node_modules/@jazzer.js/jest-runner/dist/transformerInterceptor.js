"use strict";
/*
 * Copyright 2023 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interceptScriptTransformerCalls = void 0;
// Disable ban-types to use Function as type in interceptions.
/* eslint-disable @typescript-eslint/ban-types */
const fs_1 = __importDefault(require("fs"));
const tmp_1 = __importDefault(require("tmp"));
tmp_1.default.setGracefulCleanup();
// Code containing coverage instrumentation calls is considered to be instrumented.
const INSTRUMENTATION_MARKER = "Fuzzer.coverageTracker.incrementCounter";
function interceptScriptTransformerCalls(runtime, instrumentor) {
    const scriptTransformer = runtime["_scriptTransformer"];
    // _buildTransformResult is used in transformSource and transformSourceAsync
    // and creates a cache file for the transformed code. We instrument and hence change
    // the result, so that the cache file does not match anymore and transformation happens
    // every time. This prevents loading wrongly (not) instrumented versions from previous
    // runs with different configurations.
    intercept(scriptTransformer, "_buildTransformResult", (original) => (filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath) => {
        const result = original(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);
        if (!result || isInstrumented(result.code)) {
            return result;
        }
        const instrumented = instrumentor.instrument(result.code, filename, sourceMapContent(sourceMapPath));
        if (instrumented?.map) {
            sourceMapPath = writeSourceMap(instrumented.map);
        }
        return {
            code: instrumented?.code ?? result.code,
            originalCode: result.originalCode,
            sourceMapPath: sourceMapPath,
        };
    });
    // _transformAndBuildScript can call transformSource, which requires checks to
    // prevent double instrumentation.
    // As the original result could already apply transformations the result includes
    // a source map path, which the instrumentor needs to take into account for its
    // instrumentation. The result is not saved in a cache file and can be changed
    // directly to point to a dumped source map file.
    intercept(scriptTransformer, "_transformAndBuildScript", (original) => (filename, options, transformOptions, fileSource) => {
        const originalResult = original(filename, options, transformOptions, fileSource);
        return processTransformResult(originalResult, filename, instrumentor);
    });
    // Similar to _transformAndBuildScript, but async. Is used to load ESM modules.
    intercept(scriptTransformer, "_transformAndBuildScriptAsync", (original) => async (filename, options, transformOptions, fileSource) => {
        const originalResult = await original(filename, options, transformOptions, fileSource);
        return processTransformResult(originalResult, filename, instrumentor);
    });
}
exports.interceptScriptTransformerCalls = interceptScriptTransformerCalls;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function intercept(obj, name, interceptor) {
    obj[name] = interceptor(obj[name].bind(obj));
}
function isInstrumented(code) {
    return code.includes(INSTRUMENTATION_MARKER);
}
function processTransformResult(originalResult, filename, instrumentor) {
    // If already instrumented by previous calls or internal invocation of
    // transformSource simply return the original result.
    if (isInstrumented(originalResult.code)) {
        return originalResult;
    }
    const sourceMap = sourceMapContent(originalResult.sourceMapPath);
    const instrumented = instrumentor.instrument(originalResult.code, filename, sourceMap);
    if (!instrumented) {
        return originalResult;
    }
    // Source map path is only set if a transformation happened, in that case the
    // code should be instrumented via the other intercepted method.
    let sourceMapPath = originalResult.sourceMapPath;
    if (instrumented?.map) {
        sourceMapPath = writeSourceMap(instrumented.map);
    }
    return {
        code: instrumented.code ?? originalResult.code,
        sourceMapPath: sourceMapPath,
        originalCode: originalResult.originalCode,
    };
}
function writeSourceMap(sourceMap) {
    const sourceMapPath = tmp_1.default.fileSync({ prefix: "jazzerjs-map" }).name;
    fs_1.default.writeFileSync(sourceMapPath, JSON.stringify(sourceMap));
    return sourceMapPath;
}
function sourceMapContent(sourceMapPath) {
    if (sourceMapPath) {
        try {
            return JSON.parse(fs_1.default.readFileSync(sourceMapPath).toString());
        }
        catch (e) {
            // Ignore missing source map
        }
    }
}
//# sourceMappingURL=transformerInterceptor.js.map