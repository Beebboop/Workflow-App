"use strict";
/*
 * Copyright 2023 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Corpus = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class Corpus {
    static defaultCorpusDirectory = ".cifuzz-corpus";
    // Directory containing manually generated user seeds and found
    // fuzzer inputs (crash, timeout, ...).
    _seedInputsDirectory;
    // Directory containing runtime generated fuzzer inputs.
    _generatedInputsDirectory;
    // Indicate if coverage is enabled.
    _coverage;
    constructor(testSourceFilePath, testJestPathElements, coverage = false) {
        this._seedInputsDirectory = directoryPathForTest(testSourceFilePath, testJestPathElements);
        this._generatedInputsDirectory = directoryPathForTest(testSourceFilePath, testJestPathElements, Corpus.defaultCorpusDirectory);
        this._coverage = coverage;
        createMissingDirectories(this._seedInputsDirectory, this._generatedInputsDirectory);
    }
    get seedInputsDirectory() {
        return this._seedInputsDirectory;
    }
    get generatedInputsDirectory() {
        return this._generatedInputsDirectory;
    }
    inputsPaths() {
        const seedInputs = this.inputFiles(this._seedInputsDirectory);
        if (this._coverage) {
            return seedInputs.concat(this.inputFiles(this._generatedInputsDirectory));
        }
        return seedInputs;
    }
    inputFiles(directory) {
        return fs_1.default
            .readdirSync(directory)
            .filter((entry) => !fs_1.default.lstatSync(path_1.default.join(directory, entry)).isDirectory())
            .map((file) => [file, path_1.default.join(directory, file)]);
    }
}
exports.Corpus = Corpus;
const createMissingDirectories = (...dirs) => dirs.forEach((dir) => fs_1.default.mkdirSync(dir, { recursive: true }));
const directoryPathForTest = (testSourceFilePath, testJestPathElements, addToProjectRoot = "") => {
    const rootDirectory = buildRootDirectory(testSourceFilePath, addToProjectRoot);
    const safeTestJestPathElements = testJestPathElements.map(replaceSpacesWithUnderscore);
    return path_1.default.join(rootDirectory, ...safeTestJestPathElements, path_1.default.sep);
};
const buildRootDirectory = (testSourceFilePath, projectCorpusRoot) => {
    const inputsRoot = path_1.default.parse(testSourceFilePath);
    const testName = inputsRoot.name;
    if (projectCorpusRoot !== "") {
        // looking for the root directory of the project
        return path_1.default.join(findDirectoryWithPackageJson(inputsRoot).dir, projectCorpusRoot, testName);
    }
    else {
        return path_1.default.join(inputsRoot.dir, testName);
    }
};
const findDirectoryWithPackageJson = (directory) => {
    while (!fs_1.default.readdirSync(directory.dir).includes("package.json")) {
        directory = path_1.default.parse(directory.dir);
        if (directory.dir === directory.root) {
            throw new Error("Could not find package.json in any parent directory");
        }
    }
    return directory;
};
const replaceSpacesWithUnderscore = (s) => {
    return s.replace(/ /g, "_");
};
//# sourceMappingURL=corpus.js.map