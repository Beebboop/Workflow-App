"use strict";
/*
 * Copyright 2023 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInRegressionMode = exports.runInFuzzingMode = exports.fuzz = exports.skip = exports.FuzzerError = void 0;
const fs = __importStar(require("fs"));
const core_1 = require("@jazzer.js/core");
const config_1 = require("./config");
const corpus_1 = require("./corpus");
const errorUtils_1 = require("./errorUtils");
// Indicate that something went wrong executing the fuzzer.
class FuzzerError extends Error {
}
exports.FuzzerError = FuzzerError;
const skip = (globals) => (name) => {
    globals.test.skip(toTestName(name), () => {
        return;
    });
};
exports.skip = skip;
function printTestNameIfRequested(testStatePath) {
    const full_name = testStatePath.join(" ");
    if (process.env.JAZZER_LIST_FUZZTEST_NAMES) {
        if (process.env.JAZZER_LIST_FUZZTEST_NAMES_PATTERN == undefined ||
            full_name.match(process.env.JAZZER_LIST_FUZZTEST_NAMES_PATTERN)) {
            if (process.env.JAZZER_LIST_FUZZTEST_NAMES == "short") {
                const short_name = testStatePath.pop() || "";
                console.log(short_name);
            }
            else if (process.env.JAZZER_LIST_FUZZTEST_NAMES == "split") {
                const split_name = testStatePath.join(" / ");
                console.log(split_name);
            }
            else {
                console.log(full_name);
            }
        }
    }
}
function fuzz(globals, testFile, fuzzingConfig, currentTestState, currentTestTimeout, originalTestNamePattern, mode) {
    return (name, fn, timeout) => {
        // Deep clone the fuzzing config, so that each test can modify it without
        // affecting other tests, e.g. set a test specific timeout.
        const localConfig = JSON.parse(JSON.stringify(fuzzingConfig));
        const state = currentTestState();
        if (!state) {
            throw new Error("No test state found");
        }
        // Add tests that don't match the test name pattern as skipped, so that
        // only the requested tests are executed.
        const testStatePath = currentTestStatePath(toTestName(name), state);
        const testNamePattern = originalTestNamePattern();
        printTestNameIfRequested(testStatePath);
        const skip = testStatePath !== undefined &&
            testNamePattern != undefined &&
            !testNamePattern.test(testStatePath.join(" "));
        if (skip) {
            globals.test.skip(name, () => {
                // Ignore
            });
            return;
        }
        const corpus = new corpus_1.Corpus(testFile, testStatePath, localConfig.coverage);
        // Timeout priority is:
        // 1. Use timeout directly defined in test function
        // 2. Use timeout defined in fuzzing config
        // 3. Use jest timeout
        if (timeout != undefined) {
            localConfig.timeout = timeout;
        }
        else {
            const jestTimeout = currentTestTimeout();
            if (jestTimeout != undefined && localConfig.timeout == undefined) {
                localConfig.timeout = jestTimeout;
            }
            else if (localConfig.timeout === config_1.TIMEOUT_PLACEHOLDER) {
                localConfig.timeout = core_1.defaultOptions.timeout;
            }
        }
        const wrappedFn = (0, core_1.asFindingAwareFuzzFn)(fn, localConfig.mode === "fuzzing");
        if (localConfig.mode === "regression") {
            (0, exports.runInRegressionMode)(name, wrappedFn, corpus, localConfig, globals, mode);
        }
        else if (localConfig.mode === "fuzzing") {
            (0, exports.runInFuzzingMode)(name, wrappedFn, corpus, localConfig, globals, mode);
        }
        else {
            throw new Error(`Unknown mode ${localConfig.mode}`);
        }
    };
}
exports.fuzz = fuzz;
const runInFuzzingMode = (name, fn, corpus, options, globals, mode) => {
    handleMode(mode, globals.test)(name, async () => {
        options.fuzzerOptions.unshift(corpus.seedInputsDirectory);
        options.fuzzerOptions.unshift(corpus.generatedInputsDirectory);
        options.fuzzerOptions.push("-artifact_prefix=" + corpus.seedInputsDirectory);
        return (0, core_1.startFuzzingNoInit)(fn, options).then(({ error }) => {
            // Throw the found error to mark the test as failed.
            if (error)
                throw error;
        });
    });
};
exports.runInFuzzingMode = runInFuzzingMode;
const runInRegressionMode = (name, fn, corpus, options, globals, mode) => {
    handleMode(mode, globals.describe)(name, () => {
        function executeTarget(content) {
            return new Promise((resolve, reject) => {
                // Fuzz test expects a done callback, if more than one parameter is specified.
                if (fn.length > 1) {
                    doneCallbackPromise(fn, content, resolve, reject);
                }
                else {
                    // Support sync and async fuzz tests.
                    Promise.resolve()
                        .then(() => fn(content))
                        .then(resolve, reject);
                }
            });
        }
        // Always execute target function with an empty buffer.
        globals.test("<empty>", async () => executeTarget(Buffer.from("")), options.timeout);
        // Execute the fuzz test with each input file as no libFuzzer is required.
        corpus.inputsPaths().forEach(([seed, path]) => {
            globals.test(seed, async () => executeTarget(await fs.promises.readFile(path)), options.timeout);
        });
    });
};
exports.runInRegressionMode = runInRegressionMode;
const doneCallbackPromise = (fn, content, resolve, reject) => {
    try {
        let doneCalled = false;
        const doneCallback = (e) => {
            if (doneCalled) {
                // As the promise was already resolved in the last invocation, and
                // there could be quite some time until this one, there is not much we
                // can do besides printing an error message.
                console.error("ERROR: Expected done to be called once, but it was called multiple times.");
            }
            doneCalled = true;
            let error;
            if (typeof e === "string") {
                error = (0, errorUtils_1.removeTopFramesFromError)(new Error(e), 1);
            }
            else {
                error = e;
            }
            error ? reject(error) : resolve(undefined);
        };
        const result = fn(content, doneCallback);
        // Expecting a done callback, but returning a promise, is invalid. This is
        // already prevented by TypeScript, but we should still check for this
        // situation due to untyped JavaScript fuzz tests.
        // Ignore other return values, as they are not relevant for the fuzz test.
        // @ts-ignore
        if (result && typeof result.then === "function") {
            reject(new FuzzerError("Either async or done callback based fuzz tests allowed"));
        }
    }
    catch (e) {
        reject(e);
    }
};
function handleMode(mode, test) {
    switch (mode) {
        case "skip":
            return test.skip;
        case "only":
            return test.only;
    }
    return test;
}
const toTestName = (name) => {
    switch (typeof name) {
        case "string":
            return name;
        case "number":
            return `${name}`;
        case "function":
            if (name.name) {
                return name.name;
            }
    }
    throw new FuzzerError(`Invalid test name "${name}"`);
};
const currentTestStatePath = (name, state) => {
    const elements = [name];
    let describeBlock = state;
    while (describeBlock.parent) {
        elements.unshift(describeBlock.name);
        if (describeBlock.parent) {
            describeBlock = describeBlock.parent;
        }
    }
    return elements;
};
//# sourceMappingURL=fuzz.js.map