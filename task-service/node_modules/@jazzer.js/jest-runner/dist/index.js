"use strict";
/*
 * Copyright 2023 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.includeImplicitElseBranches = void 0;
const libCoverage = __importStar(require("istanbul-lib-coverage"));
const core_1 = require("@jazzer.js/core");
const config_1 = require("./config");
const errorUtils_1 = require("./errorUtils");
const globalsInterceptor_1 = require("./globalsInterceptor");
const testStateInterceptor_1 = require("./testStateInterceptor");
const transformerInterceptor_1 = require("./transformerInterceptor");
async function jazzerTestRunner(globalConfig, config, environment, runtime, testPath, sendMessageToJest) {
    const vmContext = environment.getVmContext();
    if (vmContext === null)
        throw new Error("vmContext is undefined");
    const jazzerConfig = (0, config_1.loadConfig)({
        coverage: globalConfig.collectCoverage,
        coverageReporters: globalConfig.coverageReporters,
    });
    const globalEnvironments = [environment.getVmContext(), globalThis];
    (0, core_1.registerGlobals)(jazzerConfig, globalEnvironments);
    (0, core_1.setJazzerJsGlobal)("vmContext", vmContext);
    const instrumentor = await (0, core_1.initFuzzing)(jazzerConfig);
    (0, transformerInterceptor_1.interceptScriptTransformerCalls)(runtime, instrumentor);
    const testState = (0, testStateInterceptor_1.interceptTestState)(environment, jazzerConfig);
    (0, globalsInterceptor_1.interceptGlobals)(runtime, testPath, jazzerConfig, testState);
    const circusRunner = await runtime["_scriptTransformer"].requireAndTranspileModule("jest-circus/runner");
    return circusRunner(globalConfig, config, environment, runtime, testPath, sendMessageToJest).then((result) => {
        includeImplicitElseBranches(environment.global.__coverage__);
        return cleanupTestResultDetails(result);
    });
}
exports.default = jazzerTestRunner;
function cleanupTestResultDetails(result) {
    // Some errors, like timeouts, are created in Jest's test runner and need to be
    // post-processed to remove internal stack frames in this way.
    result.testResults.forEach((testResult) => {
        testResult.failureDetails?.forEach(errorUtils_1.cleanupJestError);
        testResult.failureMessages = testResult.failureMessages?.map((failureMessage) => (0, errorUtils_1.cleanupJestRunnerStack)(failureMessage) ?? "");
    });
    if (result.failureMessage) {
        result.failureMessage = (0, errorUtils_1.cleanupJestRunnerStack)(result.failureMessage);
    }
    return result;
}
/**
 * Coverage fix from https://github.com/vitest-dev/vitest/pull/2275
 * In our tests this seems to only affect the coverage of TypeScript files,
 * hence including the fix in jest-runner should be sufficient.
 *
 * Original comment:
 * Work-around for #1887 and #2239 while waiting for https://github.com/istanbuljs/istanbuljs/pull/706
 * Goes through all files in the coverage map and checks if branchMap's have
 * if-statements with implicit else. When finds one, copies source location of
 * the if-statement into the else statement.
 */
function includeImplicitElseBranches(coverageMapData) {
    if (!coverageMapData) {
        return;
    }
    function isEmptyCoverageRange(range) {
        return (range.start === undefined ||
            range.start.line === undefined ||
            range.start.column === undefined ||
            range.end === undefined ||
            range.end.line === undefined ||
            range.end.column === undefined);
    }
    const coverageMap = libCoverage.createCoverageMap(coverageMapData);
    for (const file of coverageMap.files()) {
        const fileCoverage = coverageMap.fileCoverageFor(file);
        for (const branchMap of Object.values(fileCoverage.branchMap)) {
            if (branchMap.type === "if") {
                const lastIndex = branchMap.locations.length - 1;
                if (lastIndex > 0) {
                    const elseLocation = branchMap.locations[lastIndex];
                    if (elseLocation && isEmptyCoverageRange(elseLocation)) {
                        const ifLocation = branchMap.locations[0];
                        elseLocation.start = { ...ifLocation.start };
                        elseLocation.end = { ...ifLocation.end };
                    }
                }
            }
        }
    }
}
exports.includeImplicitElseBranches = includeImplicitElseBranches;
//# sourceMappingURL=index.js.map